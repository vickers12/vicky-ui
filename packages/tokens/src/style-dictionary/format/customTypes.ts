import type { Dictionary } from "style-dictionary";

import { toPascalCase } from "../helpers";

export const customTypes = function ({ dictionary }: { dictionary: Dictionary }) {
    const groupedTypes = new Map<string, Set<string>>();
    const roleBasedTypes = new Map<string, Set<string>>();
    const roleMappings = new Map<string, Map<string, string>>();
    const coreColorTokens = new Set<string>();
    const coreColorMappings = new Map<string, string>();

    // Collect all tokens, groupings, and mappings
    for (const token of dictionary.allTokens) {
        const { type, name, attributes } = token;
        if (!type || !name) {continue;}

        // Add to groupedTypes for everything
        if (!groupedTypes.has(type)) {groupedTypes.set(type, new Set());}
        groupedTypes.get(type)!.add(`'${name}'`);

        if (type === "color") {
            const role = attributes?.role;
            if (typeof role === "string") {
                // Semantic color: add to role groups & mappings, using short name
                const shortName = name.replace(new RegExp(`-${role}(?=-|$)`), "");
                if (!roleBasedTypes.has(role)) {roleBasedTypes.set(role, new Set());}
                roleBasedTypes.get(role)!.add(`'${shortName}'`);

                if (!roleMappings.has(role)) {roleMappings.set(role, new Map());}
                roleMappings.get(role)!.set(`'${shortName}'`, `'${name}'`);
            } else {
                // Core color: no role
                coreColorTokens.add(`'${name}'`);
                coreColorMappings.set(`'${name}'`, `'${name}'`);
            }
        }
    }

    // Types (not including color)
    const typesOutput = [...groupedTypes.entries()]
        .filter(([type]) => type !== "color")
        .map(([type, values]) => {
            const typeName = `${toPascalCase(type)}Token`;

            return `export type ${typeName} = ${[...values].join(" | ")};`;
        })
        .join("\n\n");

    // Role-based color token types
    const roleTypesOutput = [...roleBasedTypes.entries()]
        .map(([role, values]) => {
            const typeName = `Color${toPascalCase(role)}Token`;

            return `export type ${typeName} = ${[...values].join(" | ")};`;
        })
        .join("\n\n");

    // Core color palette type (no role)
    const coreColorType = coreColorTokens.size
        ? `export type ColorToken = ${[...coreColorTokens].join(" | ")};`
        : "";

    // Now build the nested Map:
    // color: (role: Map) + all core tokens: Map
    const colorMapEntries: string[] = [];
    // 1. role-based colors as: ["surface", new Map([...])]
    for (const [role, map] of roleMappings.entries()) {
        colorMapEntries.push(
            `    ["${role}", new Map([\n${[...map.entries()].map(([short, full]) => `      [${short}, ${full}]`).join(",\n")}\n    ])]`
        );
    }
    // 2. core colors as: ["keppel-100", "keppel-100"]
    if (coreColorMappings.size) {
        colorMapEntries.push(
            `    ["core", new Map([\n${[...coreColorMappings.entries()]
                .map(([short, full]) => `      [${short}, ${full}]`)
                .join(",\n")}\n    ])]`
        );
    }

    // 3. Non-color tokens as: ["space", new Map([...])]
    const nonColorEntries = [...groupedTypes.entries()]
        .filter(([type]) => type !== "color")
        .map(([type, values]) => {
            return `  ["${type}", new Map([\n${[...values]
                .map(v => `    [${v}, ${v}]`)
                .join(",\n")}\n  ])]`;
        });

    const mappingsOutput =
        "\n\nexport const styledSystemToTokenMappings = new Map<string, any>([\n" +
        `  ["color", new Map([\n${colorMapEntries.join(",\n")}\n  ])],\n` +
        nonColorEntries.join(",\n") +
        "\n])\n";

    return `// Auto-generated by Style Dictionary

${typesOutput}
${roleTypesOutput}
${coreColorType}
${mappingsOutput}`;
};
